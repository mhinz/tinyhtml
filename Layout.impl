IMPLEMENTATION Layout

-- IMPORTS {{{1

IMPORT WinFontMetrics  COMPLETELY
       WinConfig       COMPLETELY
       Real            COMPLETELY
       Nat             COMPLETELY
       NatConv         COMPLETELY
       String          COMPLETELY
       StringConv      COMPLETELY

       Seq             COMPLETELY
       SeqMap          ONLY map
       SeqReduce       ONLY reduce

       Settings        COMPLETELY
       Dot             COMPLETELY
       Types           COMPLETELY

-- GLOBAL FUNCTIONS {{{1

DEF computeLayout (<>, _)      == <>
DEF computeLayout (pars, metr) == flatLine(lines(flatPara(layPar(pars, top'Settings, metr))))

FUN layPar : seq[par] ** real ** metrics -> seq[para]
DEF layPar (<>, _, _)                             == <>
DEF layPar (par(content, align) :: pars, y, metr) ==
    LET
        lines      == breakLines(content, metr)
        wordsPos   == computePosition(lines, align, y, metr)
        wordsWidth == widthWords(lines, metr)
        yNew       == asReal(#(lines)) * (height(metr) + lineskip(metr))
    IN
        zip2data(lines, wordsPos, wordsWidth) :: layPar(pars, y + yNew, metr)


/*
 * Wordwidths
 */
FUN widthWords : seq[seq[string]] ** metrics -> seq[seq[real]]
DEF widthWords (<>, _)               == <>
DEF widthWords (line :: lines, metr) == widthWordsInLine(line, metr) :: widthWords(lines, metr)

FUN width : string ** metrics -> real
DEF width (word, metr) == width
    WHERE
        (width, height) == dimensions(metr)(`(word))

FUN widthWordsInLine : seq[string] ** metrics -> seq[real]
DEF widthWordsInLine (<>, _)                == <>
DEF widthWordsInLine (word :: rWords, metr) == width(word, metr) :: widthWordsInLine(rWords, metr)




FUN computePosition : seq[seq[string]] ** alignment ** real ** metrics -> seq[seq[point]]
DEF computePosition (<>, _, _, _)                   == <>
DEF computePosition (line :: lines, align, y, metr) ==
    LET
        yNew   == y + height(metr) + lineskip(metr)
        points == IF left?(align) THEN getPointsLeft(line, left'Settings, y, metr)
                                  ELSE getPointsLeft(line, left'Settings, y, metr) FI
    IN
        points :: computePosition(lines, align, yNew, metr)


FUN getPointsLeft : seq[string] ** real ** real ** metrics -> seq[point]
DEF getPointsLeft (<>, _, _, _)               == <>
DEF getPointsLeft (word :: words, x, y, metr) ==
    (x @ y) :: getPointsLeft(words, xNew, y, metr)
        WHERE
            xNew == x + width(word, metr)


FUN breakLines : seq[string] ** metrics -> seq[seq[string]]
DEF breakLines (<>, _)               == <>
DEF breakLines (word :: words, metr) ==
    LET
        w            == width(word, metr)
        k            == 1 + fit(pageWidth - w, metr)(words)
        (line, tail) == split(k, words)
    IN
        line :: breakLines(tail, metr)

-- Zeilen in Paragraph
FUN zip2data : seq[seq[string]] ** seq[seq[point]] ** seq[seq[real]] -> para
DEF zip2data (<>, _, _)                  == para(<>)
DEF zip2data (t :: rt, p :: rp, w :: rw) == zip2data(rt, rp, rw) <* zip2data2(t, p, w)

-- WÃ¶rter pro Zeile
FUN zip2data2 : seq[string] ** seq[point] ** seq[real] -> line
DEF zip2data2 (<>, _, _)         == line(<>)
DEF zip2data2 (t::T, p::P, w::W) == zip2data2(T, P, W) << posWord(t, p, w)

FUN fit : real ** metrics -> seq[string] -> nat
DEF fit (_, _)(<>)                   == 0
DEF fit (supply, metr)(word :: rest) ==
    LET
        needed == glue(metr) + width(word, metr)
    IN
        IF needed <= supply THEN 1 + fit(supply - needed, metr)(rest)
                            ELSE 0 FI

FUN pageWidth : real
DEF pageWidth == canvasWidth'Settings - (2 * margin'Settings)

FUN glue : metrics -> real
DEF glue (metr) == width(!(" "), metr)
